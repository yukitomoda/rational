import { Ratio, ratio } from '../Ratio';
import { parse as internalParse } from './parser.autogenerated';
import { type PointNumber, type FractionNumber, type Integer } from './types';

function parse(str: string): Ratio {
  const parseResult = internalParse(str);
  switch (parseResult.type) {
    case 'Integer':
      return ratio(convertInteger(parseResult));
    case 'FractionNumber':
      return convertFractionNumber(parseResult);
    case 'PointNumber':
      return convertPointNumber(parseResult);
  }
}

function convertInteger(i: Integer): bigint {
  return i.sign * i.number * i.base ** i.exponent;
}

function convertFractionNumber(f: FractionNumber): Ratio {
  const numerator =
    f.numerator.type === 'Integer' ? new Ratio(convertInteger(f.numerator), 1n) : convertPointNumber(f.numerator);
  const denominator =
    f.denominator.type === 'Integer' ? new Ratio(convertInteger(f.denominator), 1n) : convertPointNumber(f.denominator);
  return numerator.div(denominator);
}

function convertPointNumber(p: PointNumber): Ratio {
  let denominator = 1n;
  let numerator = p.intPart.number;

  if (p.fracPart != null) {
    const denom = p.fracPart.base ** BigInt(p.fracPart.length);
    denominator *= denom;
    numerator = numerator * denom + p.fracPart.number;
  }

  if (p.cyclicPart != null) {
    const multiplier = p.cyclicPart.base ** BigInt(p.cyclicPart.length);
    denominator *= multiplier - 1n;
    numerator = numerator * multiplier + p.cyclicPart.number - numerator;
  }

  if (p.exponent != null) {
    if (p.exponent > 0) {
      numerator *= p.intPart.base ** p.exponent;
    } else if (p.exponent < 0) {
      denominator *= p.intPart.base ** p.exponent;
    }
  }

  if (p.sign != null) {
    numerator *= p.sign;
  }

  return ratio(numerator, denominator);
}

export { parse };
