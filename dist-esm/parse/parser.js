import { Ratio, ratio } from '../Ratio';
import { parse as internalParse } from './parser.autogenerated';
function parse(str) {
    const parseResult = internalParse(str);
    switch (parseResult.type) {
        case 'Integer':
            return ratio(convertInteger(parseResult));
        case 'FractionNumber':
            return convertFractionNumber(parseResult);
        case 'PointNumber':
            return convertPointNumber(parseResult);
    }
}
function convertInteger(i) {
    return i.sign * i.number * i.base ** i.exponent;
}
function convertFractionNumber(f) {
    const numerator = f.numerator.type === 'Integer' ? new Ratio(convertInteger(f.numerator), 1n) : convertPointNumber(f.numerator);
    const denominator = f.denominator.type === 'Integer' ? new Ratio(convertInteger(f.denominator), 1n) : convertPointNumber(f.denominator);
    return numerator.div(denominator);
}
function convertPointNumber(p) {
    let denominator = 1n;
    let numerator = p.intPart.number;
    if (p.fracPart != null) {
        const denom = p.fracPart.base ** BigInt(p.fracPart.length);
        denominator *= denom;
        numerator = numerator * denom + p.fracPart.number;
    }
    if (p.cyclicPart != null) {
        const multiplier = p.cyclicPart.base ** BigInt(p.cyclicPart.length);
        denominator *= multiplier - 1n;
        numerator = numerator * multiplier + p.cyclicPart.number - numerator;
    }
    if (p.exponent != null) {
        if (p.exponent > 0) {
            numerator *= p.intPart.base ** p.exponent;
        }
        else if (p.exponent < 0) {
            denominator *= p.intPart.base ** -p.exponent;
        }
    }
    if (p.sign != null) {
        numerator *= p.sign;
    }
    return ratio(numerator, denominator);
}
export { parse };
//# sourceMappingURL=parser.js.map