"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parse = void 0;
const Ratio_1 = require("../Ratio");
const parser_autogenerated_1 = require("./parser.autogenerated");
function parse(str) {
    const parseResult = (0, parser_autogenerated_1.parse)(str);
    switch (parseResult.type) {
        case 'Integer':
            return (0, Ratio_1.ratio)(convertInteger(parseResult));
        case 'FractionNumber':
            return convertFractionNumber(parseResult);
        case 'PointNumber':
            return convertPointNumber(parseResult);
    }
}
exports.parse = parse;
function convertInteger(i) {
    return i.sign * i.number * i.base ** i.exponent;
}
function convertFractionNumber(f) {
    const numerator = f.numerator.type === 'Integer' ? new Ratio_1.Ratio(convertInteger(f.numerator), 1n) : convertPointNumber(f.numerator);
    const denominator = f.denominator.type === 'Integer' ? new Ratio_1.Ratio(convertInteger(f.denominator), 1n) : convertPointNumber(f.denominator);
    return numerator.div(denominator);
}
function convertPointNumber(p) {
    let denominator = 1n;
    let numerator = p.intPart.number;
    if (p.fracPart != null) {
        const denom = p.fracPart.base ** BigInt(p.fracPart.length);
        denominator *= denom;
        numerator = numerator * denom + p.fracPart.number;
    }
    if (p.cyclicPart != null) {
        const multiplier = p.cyclicPart.base ** BigInt(p.cyclicPart.length);
        denominator *= multiplier - 1n;
        numerator = numerator * multiplier + p.cyclicPart.number - numerator;
    }
    if (p.exponent != null) {
        if (p.exponent > 0) {
            numerator *= p.intPart.base ** p.exponent;
        }
        else if (p.exponent < 0) {
            denominator *= p.intPart.base ** p.exponent;
        }
    }
    if (p.sign != null) {
        numerator *= p.sign;
    }
    return (0, Ratio_1.ratio)(numerator, denominator);
}
//# sourceMappingURL=parser.js.map